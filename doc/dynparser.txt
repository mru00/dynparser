= dynparser - a dynamic parser that can extend the syntax during runtime
mru
2011-03

[abstract]
== Abstract
--
'dynparser' is a python package that provides a runtime-configurable
parser.

It is a true LL(n) parser and uses backtracking to achieve LL(n).
--

:numbered:


== Overview

Terminal and Nonterminal symbols are represented as python
classes.

To create a Nonterminal, derive from `NTE`:

[code,python]
---------------------------------------------
class Program(NTE):pass
---------------------------------------------

A Terminal Symbol is derived from `TE` and can create a regular
expression to direct to tokenizer:

[code,python]
---------------------------------------------
class Value(TE):
	expression = re.compile("\d+")
---------------------------------------------

`TE` provides a defaul-re: `\w+`.

The syntax is created by adding rules to a database:

[code,python]
---------------------------------------------
add_rule(Program, [ "constant", Value ])
---------------------------------------------

Such a syntax can be parsed easily:

[code,python]
---------------------------------------------
parse_tree = parse("constant 123")
---------------------------------------------


== Options through inheritance

To add an additional rule in the syntax, inheritance can be utilized.

[code,python]
---------------------------------------------
class Program(NTE):pass
class Statement(NTE):pass
class PrintStatement(Statement):pass
class SetStatement(Statement):pass

add_rule(PrintStatement, [ "print", Value ] )
add_rule(SetStatement, [ "set", Name, "=", Value] )
add_rule(Program, [ Statement ])
---------------------------------------------

The parser will detect the inheritance and try to match
`PrintStatement` as well as `SetStatement` when a `Statement` is
required.

This would represent the EBNF:

---------------------------------------------
Program: 
  Statement
  .
Statement: 
  PrintStatement 
  | SetStatement
  .
PrintStatement: 
  "print" Value
  .
SetStatement: 
  "set" Name "=" Value
  .
---------------------------------------------


== Choices

Take this EBNF:

---------------------------------------------
SimpleProgram:
  "{" SimpleProgram "}"
  | "x"
  .
---------------------------------------------

To create choices, additional rules must be defined:


[code,python]
---------------------------------------------
class SimpleProgram(NTE): pass
add_rule(SimpleProgram, [ "{", SimpleProgram, "}"] )
add_rule(SimpleProgram, "x")
---------------------------------------------


This is similar to the inheritance approach above, but not identical
because an option implemented this way can have different productions,
as inhertance-choices are purely forwarind rules.


== Repetitions


Take this EBNF:

---------------------------------------------
List: Value { "," Value }
  .
---------------------------------------------


To parse lists, the following syntax is used:

[code,python]
---------------------------------------------
class Rep1(NTE):pass
class Value(NTE):pass
class List(NTE):pass
add_rule(List, [ Value, [Rep1] ])
add_rule(Rep1, [ ",", Value ])
---------------------------------------------

But this will change in future, hopefully.

== Parse Tree

The function `parse` returns the top production class
instantiated. All NTE classes have the field `items` which contain
respective TE's, NTE's instantiated. TE classes have a member `value`
bound to the parsed value.

For constant TE's ( like in this rule: ["is", "+"]), TE classes are
generated at runtime, containing a regular expression matching exactly
the given string. Those TE classes have their name set to
`"TE_"+name`, where name is exactly the given constant string.

== Hooks, Semantic actions

=== NTE.canparse, TE.canparse

This method is called on an NTE/TE when it is about to be
parsed. Semantic checks can be implemented here. When the method
returns `False`, the NTE/TE cannot be parsed.

=== TE.onparse, NTE.onparse

Called when an TE/NTE was successfully parsed. For example, this can
be used to create entries in the Namespace.

== Dynamic Syntax

Syntax rules can be added while parsing. This means one can extend the
syntax arbitrarily.

The project `hla` (https://github.com/mru00/hla) uses this. The syntax
is extended by `uses` statements. These statements import new python
modules which in turn define new TE's, NTE's and call `add_rule`. The
magic happens in the Uses.onparse method.

== Tokenizer

The tokenizer is as dynamic as the parser. Since TE's can provide the
regular expressions they match, the tokenizer can be configured at
runtime.


== Namespaces

Currently, no hierarchial namespaces are implemented. Probably this
could be done outside the parser anyway.

Namespace is provided in the module `namespace`. It provides simple
stores, indexed with strings and contain key-value-pairs.


[code,python]
---------------------------------------------
# when reading a variable
add_symbol('variable', self.items[1].value, self)
---------------------------------------------



== Examples

=== Expressions

[code,python]
---------------------------------------------
class Expression(NTE):pass
class SimpleExpression(NTE):pass
class Term(NTE):pass
class Factor(NTE):pass
class RelationalOperator(TE):
    expression=re.compile(r"=|<|>|<=|>|>=")
class AdditionOperator(TE):
    expression = re.compile("\+|-|or")
class MultiplicationOperator(TE):
    expression = re.compile("\*|/|div|mod|and")
class Variable(TE):
    expression = re.compile("\w+")
class Number(TE):
    expression = re.compile("\d+")
class Sign(TE):
    expression = re.compile("-|\+")
class SignOpt(NTE):pass

class Rep1(NTE):pass
class Rep2(NTE):pass
class Rep3(NTE):pass
add_rule(SignOpt, [Sign])
add_rule(SignOpt, [])
add_rule(Rep1, [ RelationalOperator, SimpleExpression ])
add_rule(Rep2, [ AdditionOperator, Term ])
add_rule(Rep3, [ MultiplicationOperator, Factor ])

add_rule(Expression, [ SimpleExpression, [Rep1] ])
add_rule(SimpleExpression, [ SignOpt, Term, [Rep2] ])
add_rule(Term, [ Factor, [Rep3] ])
add_rule(Factor, [ Variable ])
add_rule(Factor, [ Number ])
add_rule(Factor, [ "(", Expression, ")" ])

parse("5+4", Expression)
parse("5+((x*3) * 4-1 / 10 div y)", Expression)
parse("((x*3) * 4-1 / 10 div y)", Expression)
parse("5+((x*3) * 41 / 10 div y)", Expression)
parse("-9* (-9)", Expression)
parse("5+4+9+9+8+7", Expression)
---------------------------------------------


=== Unit Tests

Have a look at the unit tests, in `/test`. They show some features of
the parser, and real-world examples.




=== Project 'hla'

See https://github.com/mru00/hla
